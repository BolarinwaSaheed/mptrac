#INTEGRATOR rosenbrock
#LANGUAGE   C
#DRIVER     none
#HESSIAN      on                    { Do not create the Hessian matrix           }
#MEX          off                    { MEX is for Matlab, so skip it              }
#STOICMAT     on                    { Do not create stoichiometric matrix        }

#DEFVAR
O3P		=   IGNORE;
CO		=   IGNORE;

#DEFFIX
OH    =   IGNORE;
HO2 	= 	IGNORE;
O1D		=   IGNORE;

#LOOKAT CO;
#MONITOR CO;

#EQUATIONS
O3P + O2 {+M} = O3														: ko3p_o2_M;
O3P + O3 			= 2O2														:	ko3p_o3;
O1D + O2      = O3P + O2   		    				   	: ko1d_o2;
O1D + O3			= 1.5O2 + O3P										: ko1d_o3;				
O1D + H2			= OH + H												: ko1d_h2;
O1D + H2O			= OH + OH												: ko1d_ho2o;
O1D + N2			= O3D + N2											: ko1d_n2;
O1D + N2			= N2O														: ko1d_n2_2;
O1D + N2O			= PROD													: ko1d_n2o;
O1D + CH4			= CH3 + OH											: ko1d_ch4;
O1D + CO2			= O3P + CO2											: ko1d_co2;
O1D + CCl3F		= 0.1O3P + 0.1CCl3F + PROD			: ko1d_ccl3f;
O1D + CCl2F2	=	0.14O3P + 0.14CCl2F2 + PROD		: ko1d_ccl2f2;
O1D + CClF3		= 0.18O3P + 0.18CClF3 + PROD		: ko1d_cclf3;
O3P + OH			= O2 + H												: ko3p_oh;
O3P + HO2     = OH + O2												: ko3p_ho2;
O3P + H2O2		= OH + HO2											: ko3p_h2o2;
H + O2	{+M}	= HO2														: kh_o2_M;	
H + O3				= OH + O2												: kh_o3;
H + HO2				= 2OH														: kh_ho2;
H + HO2				= O + H2O												: kh_ho2_2;
H + HO2				= H2 + O2												: kh_ho2_3;
OH + O3				= HO2 + O2											: koh_o3;
OH + OH				= H2O + O3P											: koh_oh;
OH + OH {+M}	= H2O2													: koh_oh_M;
OH + HO2			= H2O	+ O2											: koh_ho2;
OH + H2O2 		= H2O + HO2											: koh_h2o2;
HO2 + O3			= OH + 2O2											: kho2_o3;
HO2 + HO2			= H2O2 + O2											: kho2_ho2

H2O + hv 			= OH + H												: 


#INLINE C_GLOBAL

void INTEGRATE( double TIN, double TOUT );

extern double ko3p_o2_M, ko3p_o3, ko1d_o2, ko1d_o3, ko1d_h2, ko1d_ho2o,
							ko1d_n2, ko1d_n2_2, ko1d_n2o, ko1d_ch4, ko1d_co2, ko1d_ccl3f,
							ko1d_ccl2f2, ko1d_cclf3, ko3p_oh, ko3p_ho2, ko3p_h2o2, kh_o2_M, 
							kh_o3, kh_ho2, kh_ho2_2, kh_ho2_3, koh_o3, koh_oh, koh_oh_M,
							koh_ho2, koh_h2o2, kho2_o3, kho2_ho2;

#pragma omp threadprivate(ko3p_o2_M, ko3p_o3, ko1d_o2, ko1d_o3, ko1d_h2, ko1d_ho2o,
													ko1d_n2, ko1d_n2_2, ko1d_n2o, ko1d_ch4, ko1d_co2, ko1d_ccl3f,
													ko1d_ccl2f2, ko1d_cclf3, ko3p_oh, ko3p_ho2, ko3p_h2o2, kh_o2_M, 
													kh_o3, kh_ho2, kh_ho2_2, kh_ho2_3, koh_o3, koh_oh, koh_oh_M,
													koh_ho2, koh_h2o2, kho2_o3, kho2_ho2,
													RCONST,RTOL,ATOL,STEPMIN,VAR,FIX,TEMP)
#ENDINLINE

#INLINE C_RATES
#include "libtrac.h"

double  k3rd_jpl (  float M, float A0, float B0, float A1, float B1)
{
  double K0, K1, Kf;

  K0 = (double)A0 * pow( (298.0/TEMP), (double)B0 ) * M;
  K1 = (double)A1 * pow( (298.0/TEMP), (double)B1 );
  Kf = (K0/(1.0+K0/K1)) *
    pow( 0.6, ( 1.0/( 1.0+pow( (log10(K0/K1)),2 ) ) ) );

  return (double)Kf;
}

#define photolysis(a, b, c, sza)
	a * exp(b * (1 - 1/cos(c * sza)))

double KaqSO2_H2O2, KSO2_OH, KHO2_HO2;

void Initialize_user(
  ctl_t * ctl,
  clim_t * clim,
  met_t * met0,
  met_t * met1,
  atm_t * atm,
	int ip
){

    if (ctl->qnt_Cso2 < 0)
      ERRMSG("Quantity variable Cso2 needed!")
    VAR[ind_SO2] = atm->q[ctl->qnt_Cso2][ip];
      if (ctl->qnt_Ch2o2 > 0)
    VAR[ind_H2O2] = atm->q[ctl->qnt_Ch2o2][ip];
      FIX[indf_OH] = clim_oh_diurnal(ctl, clim, atm->time[ip], atm->p[ip],
             atm->lon[ip], atm->lat[ip]);
      FIX[indf_HO2] = clim_ho2(clim, atm->time[ip], atm->lat[ip], atm->p[ip]);

      /* Get temperature... */
      double t, lwc;
      INTPOL_INIT;
      INTPOL_3D(t, 1);
      INTPOL_3D(lwc, 1);
			TEMP = t;

      /* Calculate air molecular density (IUPAC Data Sheet I.A4.86 SOx15)... */
      double M = AVO / RI * 1e-6 * (atm->p[ip] * 100) / t ;  // M = p/RT

			/* Calculate solar zenith angle [deg] */
			double sza = sza_calc(t, atm->lon[ip], atm->lat[ip])

      /* Reaction rate (Berglen et al., 2004)... */
      /* Rate of aqueous phase oxidation of SO2 with H2O2. (Maass et al. 1999)  */
      double k =
        9.1e7 * exp(-29700 / RI * (1. / t - 1. / 298.15)) / SQR(AVO * 1e-3); //unit: M^(-2) s-1 to {mole/cm3}^(-2) s-1. Third order coef.

      /* Henry constant of SO2... */
      double H_SO2 = 1.3e-2 * exp(2900 * (1. / t - 1. / 298.15)) * RI * t;
      double K_1S = 1.23e-2 * exp(2.01e3 * (1. / t - 1. / 298.15)) * AVO * 1e-3;	// unit: molec/cm3

      /* Henry constant of H2O2... */
      double H_h2o2 = 8.3e2 * exp(7600 * (1 / t - 1 / 298.15)) * RI * t;

      /* Volume water content in cloud [m^3 m^(-3)]... */
      double rho_air = 100 * atm->p[ip] / (RI * t) * MA / 1000; 
			//MA: Molar mass of dry air; RI: Ideal gas constant 8.314 [J/(mol K)]
      double CWC = lwc * rho_air / 1000;

      KaqSO2_H2O2 = k * K_1S * H_SO2 * H_h2o2 * CWC;	//Unit: (molec/cm3)^-1  s-1



      /* Calculate rate coefficient for X + OH + M -> XOH + M
         (JPL Publication 19-05) ... */
			KSO2_OH = k3rd_jpl(M, 2.9e-31, 4.1, 1.7e-12, -0.2); //(molec/cm3)^(-1)  s-1, effective 2nd order coef
			KHO2_HO2 = ARR_ab(3e-13, -460) + ARR_ab(2.1e-33 * M, -920) ;

}

void module_kpp_chemgrid(
  ctl_t * ctl,
  clim_t * clim,
  atm_t * atm,
  double t) {

  double *mass, *z, *lon, *lat, *press, *area, para_mixing;

  int *ixs, *iys, *izs;

  /* Update host... */
#ifdef _OPENACC
  SELECT_TIMER("UPDATE_HOST", "MEMORY", NVTX_D2H);
#pragma acc update host(atm[:1])
#endif

  /* Set timer... */
  SELECT_TIMER("MODULE_KPP_CHEMGRID", "PHYSICS", NVTX_GPU);

  /* Check quantity flags... */
  if (ctl->molmass < 0)   /* TODO: is it okay to check this here? */
    ERRMSG("SPECIES MOLAR MASS is not defined!");
  
  /* Allocate... */
	if (ctl->qnt_m > 0)
  	ALLOC(mass, double,
		ctl->chemgrid_nx * ctl->chemgrid_ny * ctl->chemgrid_nz);
  ALLOC(z, double,
	ctl->chemgrid_nz);
  ALLOC(lon, double,
	ctl->chemgrid_nx);
  ALLOC(lat, double,
	ctl->chemgrid_ny);
  ALLOC(area, double,
	ctl->chemgrid_ny);
  ALLOC(press, double,
	ctl->chemgrid_nz);
  ALLOC(ixs, int,
	atm->np);
  ALLOC(iys, int,
	atm->np);
  ALLOC(izs, int,
	atm->np);

  /* Set grid box size... */
  double dz = (ctl->chemgrid_z1 - ctl->chemgrid_z0) / ctl->chemgrid_nz;
  double dlon = (ctl->chemgrid_lon1 - ctl->chemgrid_lon0) / ctl->chemgrid_nx;
  double dlat = (ctl->chemgrid_lat1 - ctl->chemgrid_lat0) / ctl->chemgrid_ny;

  /* Set vertical coordinates... */
#pragma omp parallel for default(shared)
  for (int iz = 0; iz < ctl->chemgrid_nz; iz++) {
    z[iz] = ctl->chemgrid_z0 + dz * (iz + 0.5);
    press[iz] = P(z[iz]);
  }

  /* Set horizontal coordinates... */
#pragma omp parallel for default(shared)
  for (int ix = 0; ix < ctl->chemgrid_nx; ix++)
    lon[ix] = ctl->chemgrid_lon0 + dlon * (ix + 0.5);
#pragma omp parallel for default(shared)
  for (int iy = 0; iy < ctl->chemgrid_ny; iy++) {
    lat[iy] = ctl->chemgrid_lat0 + dlat * (iy + 0.5);
    area[iy] = dlat * dlon * SQR(RE * M_PI / 180.)
      * cos(lat[iy] * M_PI / 180.);
  }

  /* Set time interval for output... */
  double t0 = t - 0.5 * ctl->dt_mod;
  double t1 = t + 0.5 * ctl->dt_mod;

  /* Get indices... */
#pragma omp parallel for default(shared)
  for (int ip = 0; ip < atm->np; ip++) {
    ixs[ip] = (int) ((atm->lon[ip] - ctl->chemgrid_lon0) / dlon);
    iys[ip] = (int) ((atm->lat[ip] - ctl->chemgrid_lat0) / dlat);
    izs[ip] = (int) ((Z(atm->p[ip]) - ctl->chemgrid_z0) / dz);
    if (atm->time[ip] < t0 || atm->time[ip] > t1
	|| ixs[ip] < 0 || ixs[ip] >= ctl->chemgrid_nx
	|| iys[ip] < 0 || iys[ip] >= ctl->chemgrid_ny
	|| izs[ip] < 0 || izs[ip] >= ctl->chemgrid_nz)
      izs[ip] = -1;
  }

  /* Average data... */
  for (int ip = 0; ip < atm->np; ip++)
    if (izs[ip] >= 0)
      mass[ARRAY_3D
	   (ixs[ip], iys[ip], ctl->chemgrid_ny, izs[ip], ctl->chemgrid_nz)]
	+= atm->q[ctl->qnt_m][ip];
  
  /* Assign the grid data to air parcels ... */
#pragma omp parallel for default(shared)
  for (int ip = 0; ip < atm->np; ip++)
    if (izs[ip] >= 0) {
			if (ctl->chemgrid_mixparam_trop < 1 || ctl->chemgrid_mixparam_strat < 1){
				/* Get weighting factor... */
				double w = tropo_weight(clim, atm->time[ip], atm->lat[ip], atm->p[ip]);

				/* Set interparcel exchange parameter (Collins et al. 1997)... */   /* TODO: rename "interparc_*" as "chemgrid_mixparam_*" ?  */
				 para_mixing =
					w * ctl->chemgrid_mixparam_trop + (1 - w) * ctl->chemgrid_mixparam_strat;
			}
			else
				 para_mixing = 1;

      /* Calculate SO2 concentration... */  /* TODO: move this to KPP code package? */
      if (ctl->qnt_Cso2 > 0) {
	double Cso2_grid = AVO * mass[ARRAY_3D
				      (ixs[ip], iys[ip], ctl->chemgrid_ny,
				       izs[ip], ctl->chemgrid_nz)]
	  / (1e18 * area[iys[ip]] * dz * ctl->molmass);	//Unit: molec/cm3
	if (atm->q[ctl->qnt_Cso2][ip] == 0)
	  /*Initialize parcel concentration quantity... */
	  atm->q[ctl->qnt_Cso2][ip] = Cso2_grid;	//Unit: molec/cm3
	else
	  /*Bring the parcel concentration quantity closer to grid background datsa */
	  atm->q[ctl->qnt_Cso2][ip] +=
	    (Cso2_grid - atm->q[ctl->qnt_Cso2][ip]) * para_mixing;
      }

      /* Initialize H2O2 concentration... */
      if (ctl->qnt_Ch2o2 > 0)	
	if (atm->q[ctl->qnt_Ch2o2][ip] == 0)
	  atm->q[ctl->qnt_Ch2o2][ip] = clim_h2o2(clim, atm->time[ip], atm->lat[ip], atm->p[ip]);	//Unit: molec/cm3
      if (ctl->qnt_Cho2 > 0)
	if (atm->q[ctl->qnt_Cho2][ip] == 0)
	  atm->q[ctl->qnt_Cho2][ip] =
	    clim_ho2(clim, atm->time[ip], atm->lat[ip], atm->p[ip]);
    }

  /* Free... */
  free(mass);
  free(z);
  free(lon);
  free(lat);
  free(area);
  free(press);
  free(ixs);
  free(iys);
  free(izs);

  /* Update device... */
#ifdef _OPENACC
  SELECT_TIMER("UPDATE_DEVICE", "MEMORY", NVTX_H2D);
#pragma acc update device(atm[:1])
#endif
}
#ENDINLINE

void kpp_chemgrid_mass2concen(
	atm_t * atm,
	ctl_t * ctl,
	double * mass, 
	int * ixs,
	int * iys,
	int * izs,
	double molmass,
	int ip, 
	int qnt_index){

	if (qnt_index > 0) 
		atm->q[qnt_index][ip] = AVO * mass[ARRAY_3D(ixs[ip], iys[ip], ctl->chemgrid_ny,
				       				izs[ip], ctl->chemgrid_nz)]	/ 
											(1e18 * area[iys[ip]] * dz * molmass);	//Unit: molec/cm3
	else
		ERRMSG("Quantity variable %s is not defined!", ctl->qnt_name[qnt_index]);

}

