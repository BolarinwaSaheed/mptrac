// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// 
// Hessian File
// 
// Generated by KPP-3.0.0 symbolic chemistry Kinetics PreProcessor
//       (https:/github.com/KineticPreProcessor/KPP
// KPP is distributed under GPL, the general public licence
//       (http://www.gnu.org/copyleft/gpl.html)
// (C) 1995-1997, V. Damian & A. Sandu, CGRER, Univ. Iowa
// (C) 1997-2022, A. Sandu, Michigan Tech, Virginia Tech
//     With important contributions from:
//        M. Damian,   Villanova University, Philadelphia, PA, USA
//        R. Sander,   Max-Planck Institute for Chemistry, Mainz, Germany
//        M. Long,     Renaissance Fiber, LLC, North Carolina, USA
//        H. Lin,      Harvard University, Cambridge, MA, USA
//        R. Yantosca, Harvard University, Cambridge, MA, USA
// 
// File                 : chem_Hessian.c
// Equation file        : chem.kpp
// Output root filename : chem
// 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include "chem_Parameters.h"
#include "chem_Global.h"
#include "chem_Sparse.h"


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// 
// Hessian - function for Hessian (Jac derivative w.r.t. variables)
//   Arguments :
//      V         - Concentrations of variable species (local)
//      F         - Concentrations of fixed species (local)
//      RCT       - Rate constants (local)
//      HESS      - Hessian of Var (i.e. the 3-tensor d Jac / d Var)
// 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void Hessian( 
  double V[NVAR],                        /* Concentrations of variable species (local) */
  double F[NFIX],                        /* Concentrations of fixed species (local) */
  double RCT[NREACT],                    /* Rate constants (local) */
  double HESS[NHESS]                     /* Hessian of Var (i.e. the 3-tensor d Jac / d Var) */
)
{
// --------------------------------------------------------
// Note: HESS is represented in coordinate sparse format: 
//       HESS(m) = d^2 f_i / dv_j dv_k = d Jac_{i,j} / dv_k
//       where i = IHESS_I(m), j = IHESS_J(m), k = IHESS_K(m).
// --------------------------------------------------------
// Note: d^2 f_i / dv_j dv_k = d^2 f_i / dv_k dv_j, 
//       therefore only the terms d^2 f_i / dv_j dv_k
//       with j <= k are computed and stored in HESS.
// --------------------------------------------------------

// Local variables
double D2A[1];                           /* Second derivatives of equation rates */

// Computation of the second derivatives of equation rates
// D2A(0) = d^2 A(0) / dV(1)dV(2)
  D2A[0] = RCT[0];

// Computation of the Jacobian derivative
// HESS(0) = d^2 Vdot(0)/{dV(1)dV(2)} = d^2 Vdot(0)/{dV(2)dV(1)}
  HESS[0] = D2A[0];
// HESS(1) = d^2 Vdot(1)/{dV(1)dV(2)} = d^2 Vdot(1)/{dV(2)dV(1)}
  HESS[1] = -D2A[0];
// HESS(2) = d^2 Vdot(2)/{dV(1)dV(2)} = d^2 Vdot(2)/{dV(2)dV(1)}
  HESS[2] = -D2A[0];
}

// End of Hessian function
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// 
// HessTR_Vec - Hessian transposed times user vectors
//   Arguments :
//      HESS      - Hessian of Var (i.e. the 3-tensor d Jac / d Var)
//      U1        - User vector
//      U2        - User vector
//      HTU       - Transposed Hessian times user vectors: (Hess x U2)^T * U1 = [d (Jac^T*U1)/d Var] * U2 
// 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void HessTR_Vec( 
  double HESS[NHESS],                    /* Hessian of Var (i.e. the 3-tensor d Jac / d Var) */
  double U1[NVAR],                       /* User vector */
  double U2[NVAR],                       /* User vector */
  double HTU[NVAR]                       /* Transposed Hessian times user vectors: (Hess x U2)^T * U1 = [d (Jac^T*U1)/d Var] * U2  */
)
{
// Compute the vector HTU =(Hess x U2)^T * U1 = d (Jac^T*U1)/d Var * U2 
  HTU[0] = 0;
  HTU[1] = HESS[0]*(U1[0]*U2[2])+HESS[1]*(U1[1]*U2[2])+HESS[2]*(U1[2]
          *U2[2]);
  HTU[2] = HESS[0]*(U1[0]*U2[1])+HESS[1]*(U1[1]*U2[1])+HESS[2]*(U1[2]
          *U2[1]);
}

// End of HessTR_Vec function
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// 
// Hess_Vec - Hessian times user vectors
//   Arguments :
//      HESS      - Hessian of Var (i.e. the 3-tensor d Jac / d Var)
//      U1        - User vector
//      U2        - User vector
//      HU        - Hessian times user vectors: (Hess x U2) * U1 = [d (Jac*U1)/d Var] * U2
// 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void Hess_Vec( 
  double HESS[NHESS],                    /* Hessian of Var (i.e. the 3-tensor d Jac / d Var) */
  double U1[NVAR],                       /* User vector */
  double U2[NVAR],                       /* User vector */
  double HU[NVAR]                        /* Hessian times user vectors: (Hess x U2) * U1 = [d (Jac*U1)/d Var] * U2 */
)
{
// Compute the vector HU =(Hess x U2) * U1 = d (Jac*U1)/d Var * U2 
  HU[0] = HESS[0]*(U1[1]*U2[2])+HESS[0]*(U1[2]*U2[1]);
  HU[1] = HESS[1]*(U1[1]*U2[2])+HESS[1]*(U1[2]*U2[1]);
  HU[2] = HESS[2]*(U1[1]*U2[2])+HESS[2]*(U1[2]*U2[1]);
}

// End of Hess_Vec function
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


