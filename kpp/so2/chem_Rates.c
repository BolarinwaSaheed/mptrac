// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// 
// The Reaction Rates File
// 
// Generated by KPP-3.0.0 symbolic chemistry Kinetics PreProcessor
//       (https:/github.com/KineticPreProcessor/KPP
// KPP is distributed under GPL, the general public licence
//       (http://www.gnu.org/copyleft/gpl.html)
// (C) 1995-1997, V. Damian & A. Sandu, CGRER, Univ. Iowa
// (C) 1997-2022, A. Sandu, Michigan Tech, Virginia Tech
//     With important contributions from:
//        M. Damian,   Villanova University, Philadelphia, PA, USA
//        R. Sander,   Max-Planck Institute for Chemistry, Mainz, Germany
//        M. Long,     Renaissance Fiber, LLC, North Carolina, USA
//        H. Lin,      Harvard University, Cambridge, MA, USA
//        R. Yantosca, Harvard University, Cambridge, MA, USA
// 
// File                 : chem_Rates.c
// Equation file        : chem.kpp
// Output root filename : chem
// 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include "chem_Parameters.h"
#include "chem_Global.h"
#include "chem_Sparse.h"



// Begin Rate Law Functions from KPP_HOME/util/UserRateLaws

// User-defined Rate Law functions
// These are needed by saprcnov.eqn and saprc99.eqn
//
// Note: the default argument type for rate laws, as read from the
// equations file, is single precision but all the internal calculations
// are performed in double precision

// Arrhenius law for nonzero a0, b0, c0
double ARR_abc( float A0, float B0, float C0 )
{
  double ARR_RES;

  ARR_RES = (double)A0
          * exp( -(double)B0/TEMP )
          * pow( (TEMP/298.0), (double)C0 );

  return (double)ARR_RES;
}

// Arrhenius law for nonzero a0, b0
double ARR_ab( float A0, float B0 )
{
  double ARR_RES;

  ARR_RES = (double)A0 * exp( -(double)B0/TEMP );

  return (double)ARR_RES;
}

// Arrhenius law for nonzero a0, c0
double ARR_ac( float A0, float C0 )
{
  double ARR_RES;

  ARR_RES = (double)A0 * pow( (TEMP/298.0), (double)C0 );

  return (double)ARR_RES;
}

double  EP2( float A0, float C0, float A2, float C2, float A3, float C3)
{
  double K0, K2, K3, EP2_RES;

  K0 = (double)A0 * exp( -(double)C0/TEMP );
  K2 = (double)A2 * exp( -(double)C2/TEMP );
  K3 = (double)A3 * exp( -(double)C3/TEMP );
  K3 = K3*CFACTOR*1.0e+6;
  EP2_RES = K0 + K3/( 1.0+K3/K2 );

  return (double)EP2_RES;
}


double  EP3( float A1, float C1, float A2, float C2)
{
  double K1, K2, EP3_RES;

  K1 = (double)A1 * exp(-(double)C1/TEMP);
  K2 = (double)A2 * exp(-(double)C2/TEMP);
  EP3_RES = K1 + K2*(1.0e+6*CFACTOR);

  return (double)EP3_RES;
}


double  FALL (  float A0, float B0, float C0, float A1, float B1, float C1, float CF)
{
  double K0, K1, FALL_RES;

  K0 = (double)A0 * exp(-(double)B0/TEMP)* pow( (TEMP/298.0), (double)C0 );
  K1 = (double)A1 * exp(-(double)B1/TEMP)* pow( (TEMP/298.0), (double)C1 );
  K0 = K0*CFACTOR*1.0e+6;
  K1 = K0/K1;
  FALL_RES = (K0/(1.0+K1))*
    pow( (double)CF, ( 1.0/( 1.0+pow( (log10(K1)),2 ) ) ) );

  return (double)FALL_RES;
}

// End Rate Law Functions from KPP_HOME/util/UserRateLaws


// Begin INLINED Rate Law Functions


#include "libtrac.h"

double  k3rd_jpl (  float M, float A0, float B0, float A1, float B1)
{
  double K0, K1, Kf;

  K0 = (double)A0 * pow( (298.0/TEMP), (double)B0 ) * M;
  K1 = (double)A1 * pow( (298.0/TEMP), (double)B1 );
  Kf = (K0/(1.0+K0/K1)) *
    pow( 0.6, ( 1.0/( 1.0+pow( (log10(K0/K1)),2 ) ) ) );

  return (double)Kf;
}

double KaqSO2_H2O2, KSO2_OH, KHO2_HO2;

void kppchem_initialize(
  ctl_t * ctl,
  clim_t * clim,
  met_t * met0,
  met_t * met1,
  atm_t * atm,
	int ip
){

    VAR[ind_SO2] = atm->q[ctl->qnt_Cx][ip];
      if (ctl->qnt_Ch2o2 >= 0)
    VAR[ind_H2O2] = atm->q[ctl->qnt_Ch2o2][ip];
		//FIX[indf_OH]	= clim_var(clim, atm->time[ip], atm->lat[ip], atm->p[ip], clim->oh);
		FIX[indf_OH] = clim_oh_diurnal(ctl, clim, atm->time[ip], atm->p[ip],
		       atm->lon[ip], atm->lat[ip]);
      FIX[indf_HO2] = clim_var(clim, atm->time[ip], atm->lat[ip], atm->p[ip], clim->ho2);

      /* Get temperature... */
      double t, lwc;
      INTPOL_INIT;
      INTPOL_3D(t, 1);
      INTPOL_3D(lwc, 1);
			TEMP = t;

      /* Calculate air molecular density (IUPAC Data Sheet I.A4.86 SOx15)... */
      double M = MOLEC_DEN_AIR(atm->p[ip], t); 

      /* Reaction rate (Berglen et al., 2004)... */
      /* Rate of aqueous phase oxidation of SO2 with H2O2. (Maass et al. 1999)  */
      double k =
        9.1e7 * exp(-29700 / RI * (1. / t - 1. / 298.15)) / SQR(AVO * 1e-3); //unit: M^(-2) s-1 to {mole/cm3}^(-2) s-1. Third order coef.

      /* Henry constant of SO2... */
      double H_SO2 = 1.3e-2 * exp(2900 * (1. / t - 1. / 298.15)) * RI * t;
      double K_1S = 1.23e-2 * exp(2.01e3 * (1. / t - 1. / 298.15)) * AVO * 1e-3;	// unit: molec/cm3

      /* Henry constant of H2O2... */
      double H_h2o2 = 8.3e2 * exp(7600 * (1 / t - 1 / 298.15)) * RI * t;

      /* Volume water content in cloud [m^3 m^(-3)]... */
      double rho_air = 100 * atm->p[ip] / (RI * t) * MA / 1000; 
			//MA: Molar mass of dry air; RI: Ideal gas constant 8.314 [J/(mol K)]
      double CWC = lwc * rho_air / 1000;

      KaqSO2_H2O2 = k * K_1S * H_SO2 * H_h2o2 * CWC;	//Unit: (molec/cm3)^-1  s-1



      /* Calculate rate coefficient for X + OH + M -> XOH + M
         (JPL Publication 19-05) ... */
			KSO2_OH = k3rd_jpl(M, 2.9e-31, 4.1, 1.7e-12, -0.2); //(molec/cm3)^(-1)  s-1, effective 2nd order coef
			KHO2_HO2 = ARR_ab(3e-13, -460) + ARR_ab(2.1e-33 * M, -920) ;

}

// End INLINED Rate Law Functions

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// 
// Update_SUN - update SUN light using TIME
//   Arguments :
// 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void Update_SUN()
{
double SunRise, SunSet;
double Thour, Tlocal, Ttmp; 
const double PI = 3.14159265358979;  

  SunRise = 4.5;
  SunSet  = 19.5;
  Thour = TIME/3600.0;
  Tlocal = Thour - ((int)Thour/24)*24;

  if ( (Tlocal >= SunRise) && (Tlocal <= SunSet) ) {
    Ttmp = (2.0*Tlocal-SunRise-SunSet)/(SunSet-SunRise);
    if (Ttmp > 0) Ttmp =  Ttmp*Ttmp;
             else Ttmp = -Ttmp*Ttmp;
    SUN = ( 1.0 + cos(PI*Ttmp) )/2.0; 
  } else {
    SUN=0.0;
  }
}
// End of Update_SUN function
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// 
// Update_RCONST - function to update rate constants
//   Arguments :
// 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void Update_RCONST( 
)
{


// Begin INLINED RCONST


// End INLINED RCONST

  RCONST[0] = (KaqSO2_H2O2);
  RCONST[1] = (KSO2_OH);
  RCONST[2] = (KHO2_HO2);
}

// End of Update_RCONST function
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// 
// Update_PHOTO - function to update photolytical rate constants
//   Arguments :
// 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void Update_PHOTO( 
)
{

// Begin INLINED RCONST


// End INLINED RCONST

}

// End of Update_PHOTO function
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


