// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// 
// The ODE Jacobian of Chemical Model File
// 
// Generated by KPP-3.0.0 symbolic chemistry Kinetics PreProcessor
//       (https:/github.com/KineticPreProcessor/KPP
// KPP is distributed under GPL, the general public licence
//       (http://www.gnu.org/copyleft/gpl.html)
// (C) 1995-1997, V. Damian & A. Sandu, CGRER, Univ. Iowa
// (C) 1997-2022, A. Sandu, Michigan Tech, Virginia Tech
//     With important contributions from:
//        M. Damian,   Villanova University, Philadelphia, PA, USA
//        R. Sander,   Max-Planck Institute for Chemistry, Mainz, Germany
//        M. Long,     Renaissance Fiber, LLC, North Carolina, USA
//        H. Lin,      Harvard University, Cambridge, MA, USA
//        R. Yantosca, Harvard University, Cambridge, MA, USA
// 
// File                 : chem_Jacobian.c
// Equation file        : chem.kpp
// Output root filename : chem
// 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include "chem_Parameters.h"
#include "chem_Global.h"
#include "chem_Sparse.h"


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// 
// Jac_SP - the Jacobian of Variables in sparse matrix representation
//   Arguments :
//      V         - Concentrations of variable species (local)
//      F         - Concentrations of fixed species (local)
//      RCT       - Rate constants (local)
//      JVS       - sparse Jacobian of variables
// 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void Jac_SP( 
  double V[NVAR],                        /* Concentrations of variable species (local) */
  double F[NFIX],                        /* Concentrations of fixed species (local) */
  double RCT[NREACT],                    /* Rate constants (local) */
  double JVS[LU_NONZERO]                 /* sparse Jacobian of variables */
)
{

// Local variables
double B[5];                             /* Temporary array */

// B(0) = dA(0)/dV(1)
  B[0] = RCT[0]*V[2];
// B(1) = dA(0)/dV(2)
  B[1] = RCT[0]*V[1];
// B(2) = dA(1)/dV(2)
  B[2] = RCT[1]*F[0];

// Construct the Jacobian terms from B's
// JVS(0) = Jac_FULL(0,0)
  JVS[0] = 0;
// JVS(1) = Jac_FULL(0,1)
  JVS[1] = B[0];
// JVS(2) = Jac_FULL(0,2)
  JVS[2] = B[1]+B[2];
// JVS(3) = Jac_FULL(1,1)
  JVS[3] = -B[0];
// JVS(4) = Jac_FULL(1,2)
  JVS[4] = -B[1];
// JVS(5) = Jac_FULL(2,1)
  JVS[5] = -B[0];
// JVS(6) = Jac_FULL(2,2)
  JVS[6] = -B[1]-B[2];
}

// End of Jac_SP function
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// 
// Jac_SP_Vec - function for sparse multiplication: sparse Jacobian times vector
//   Arguments :
//      JVS       - sparse Jacobian of variables
//      UV        - User vector for variables
//      JUV       - Jacobian times user vector
// 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void Jac_SP_Vec( 
  double JVS[LU_NONZERO],                /* sparse Jacobian of variables */
  double UV[NVAR],                       /* User vector for variables */
  double JUV[NVAR]                       /* Jacobian times user vector */
)
{
  JUV[0] = JVS[0]*UV[0]+JVS[1]*UV[1]+JVS[2]*UV[2];
  JUV[1] = JVS[3]*UV[1]+JVS[4]*UV[2];
  JUV[2] = JVS[5]*UV[1]+JVS[6]*UV[2];
}

// End of Jac_SP_Vec function
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// 
// JacTR_SP_Vec - sparse multiplication: sparse Jacobian transposed times vector
//   Arguments :
//      JVS       - sparse Jacobian of variables
//      UV        - User vector for variables
//      JTUV      - Jacobian transposed times user vector
// 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void JacTR_SP_Vec( 
  double JVS[LU_NONZERO],                /* sparse Jacobian of variables */
  double UV[NVAR],                       /* User vector for variables */
  double JTUV[NVAR]                      /* Jacobian transposed times user vector */
)
{
  JTUV[0] = JVS[0]*UV[0];
  JTUV[1] = JVS[1]*UV[0]+JVS[3]*UV[1]+JVS[5]*UV[2];
  JTUV[2] = JVS[2]*UV[0]+JVS[4]*UV[1]+JVS[6]*UV[2];
}

// End of JacTR_SP_Vec function
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


