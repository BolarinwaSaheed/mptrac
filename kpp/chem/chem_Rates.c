// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// 
// The Reaction Rates File
// 
// Generated by KPP-3.0.0 symbolic chemistry Kinetics PreProcessor
//       (https:/github.com/KineticPreProcessor/KPP
// KPP is distributed under GPL, the general public licence
//       (http://www.gnu.org/copyleft/gpl.html)
// (C) 1995-1997, V. Damian & A. Sandu, CGRER, Univ. Iowa
// (C) 1997-2022, A. Sandu, Michigan Tech, Virginia Tech
//     With important contributions from:
//        M. Damian,   Villanova University, Philadelphia, PA, USA
//        R. Sander,   Max-Planck Institute for Chemistry, Mainz, Germany
//        M. Long,     Renaissance Fiber, LLC, North Carolina, USA
//        H. Lin,      Harvard University, Cambridge, MA, USA
//        R. Yantosca, Harvard University, Cambridge, MA, USA
// 
// File                 : chem_Rates.c
// Equation file        : chem.kpp
// Output root filename : chem
// 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include "chem_Parameters.h"
#include "chem_Global.h"
#include "chem_Sparse.h"



// Begin Rate Law Functions from KPP_HOME/util/UserRateLaws

// User-defined Rate Law functions
// These are needed by saprcnov.eqn and saprc99.eqn
//
// Note: the default argument type for rate laws, as read from the
// equations file, is single precision but all the internal calculations
// are performed in double precision

// Arrhenius law for nonzero a0, b0, c0
double ARR_abc( float A0, float B0, float C0 )
{
  double ARR_RES;

  ARR_RES = (double)A0
          * exp( -(double)B0/TEMP )
          * pow( (TEMP/298.0), (double)C0 );

  return (double)ARR_RES;
}

// Arrhenius law for nonzero a0, b0
double ARR_ab( float A0, float B0 )
{
  double ARR_RES;

  ARR_RES = (double)A0 * exp( -(double)B0/TEMP );

  return (double)ARR_RES;
}

// Arrhenius law for nonzero a0, c0
double ARR_ac( float A0, float C0 )
{
  double ARR_RES;

  ARR_RES = (double)A0 * pow( (TEMP/298.0), (double)C0 );

  return (double)ARR_RES;
}

double  EP2( float A0, float C0, float A2, float C2, float A3, float C3)
{
  double K0, K2, K3, EP2_RES;

  K0 = (double)A0 * exp( -(double)C0/TEMP );
  K2 = (double)A2 * exp( -(double)C2/TEMP );
  K3 = (double)A3 * exp( -(double)C3/TEMP );
  K3 = K3*CFACTOR*1.0e+6;
  EP2_RES = K0 + K3/( 1.0+K3/K2 );

  return (double)EP2_RES;
}


double  EP3( float A1, float C1, float A2, float C2)
{
  double K1, K2, EP3_RES;

  K1 = (double)A1 * exp(-(double)C1/TEMP);
  K2 = (double)A2 * exp(-(double)C2/TEMP);
  EP3_RES = K1 + K2*(1.0e+6*CFACTOR);

  return (double)EP3_RES;
}


double  FALL (  float A0, float B0, float C0, float A1, float B1, float C1, float CF)
{
  double K0, K1, FALL_RES;

  K0 = (double)A0 * exp(-(double)B0/TEMP)* pow( (TEMP/298.0), (double)C0 );
  K1 = (double)A1 * exp(-(double)B1/TEMP)* pow( (TEMP/298.0), (double)C1 );
  K0 = K0*CFACTOR*1.0e+6;
  K1 = K0/K1;
  FALL_RES = (K0/(1.0+K1))*
    pow( (double)CF, ( 1.0/( 1.0+pow( (log10(K1)),2 ) ) ) );

  return (double)FALL_RES;
}

// End Rate Law Functions from KPP_HOME/util/UserRateLaws


// Begin INLINED Rate Law Functions


#include "libtrac.h"

/*Formula for the effective second-order rate constant for 
	termolecular reactions (NASA JPL 19-5)... */
double  k3rd_jpl (  float M, float A0, float B0, float A1, float B1)
{
  double K0, K1, Kf;

  K0 = (double)A0 * pow( (298.0/TEMP), (double)B0 ) * M;
  K1 = (double)A1 * pow( (298.0/TEMP), (double)B1 );
  Kf = (K0/(1.0+K0/K1)) *
    pow( 0.6, ( 1.0/( 1.0+pow( (log10(K0/K1)),2 ) ) ) );

  return (double)Kf;
}

/*Formula for the effective second-order rate constant for
	chemical activation reactions (NASA JPL 19-5)... */

double  kcar_jpl (  float M, float A0, float B0, float A1, float B1, float A2, float B2)
{
  double K0, K1, Kf, Kca;

  K0 = (double)A0 * pow( (298.0/TEMP), (double)B0 ) * M;
  K1 = (double)A1 * pow( (298.0/TEMP), (double)B1 );
  Kf = (K0/(1.0+K0/K1)) *
    pow( 0.6, ( 1.0/( 1.0+pow( (log10(K0/K1)),2 ) ) ) );
	Kca = A2 * exp(-B2/TEMP) * (1 - (Kf/K1));

  return (double)(Kf + Kca);
}



double ko3p_o2_M, ko3p_o3, ko1d_o2, ko1d_o3, ko1d_h2, ko1d_h2o,
				ko1d_n2, ko1d_n2_2, ko1d_n2o, ko1d_ch4, ko1d_co2, ko1d_ccl3f,
				ko1d_ccl2f2, ko1d_cclf3, ko3p_oh, ko3p_ho2, ko3p_h2o2, kh_o2_M, 
				kh_o3, kh_ho2, kh_ho2_2, kh_ho2_3, koh_o3, koh_oh, koh_oh_M,
				koh_ho2, koh_h2o2, koh_co, kho2_o3, kho2_ho2,
				ko2_hv, ko3_hv1, ko3_hv2, kho2_hv, kh2o_hv, kh2o2_hv, kn2o_hv,
				kccl3f_hv, kcl2f2_hv;

void kppchem_initialize(
  ctl_t * ctl,
  clim_t * clim,
  met_t * met0,
  met_t * met1,
  atm_t * atm,
	int ip
){
		/* Get Meteological variables... */
		double t,  h2o;
		INTPOL_INIT;
		INTPOL_3D(t, 1);
		// INTPOL_3D(lwc, 1);
		INTPOL_3D(h2o, 1);
		TEMP = t;

		/* Calculate air molecular density (IUPAC Data Sheet I.A4.86 SOx15)... */
		double M = MOLEC_DEN_AIR(atm->p[ip], t);  

		/* Calculate solar zenith angle [deg] */
		double sza = sza_calc(atm->time[ip], atm->lon[ip], atm->lat[ip]);

		SET_VAR(ind_o3p, ctl->qnt_Co3p);
		SET_VAR(ind_o1d, ctl->qnt_Co1d);
    SET_VAR(ind_h2o2, ctl->qnt_Ch2o2);
		SET_VAR(ind_oh, ctl->qnt_Coh);
		SET_VAR(ind_ho2, ctl->qnt_Cho2);
		//SET_VAR(ind_h, ctl->qnt_Ch);
		SET_VAR(ind_o3, ctl->qnt_Co3);
		SET_VAR(ind_n2o, ctl->qnt_Cn2o);
		SET_VAR(ind_ccl3f, ctl->qnt_Cccl3f);
		SET_VAR(ind_ccl2f2, ctl->qnt_Cccl2f2);
		SET_VAR(ind_cclf3, ctl->qnt_Ccclf3);
		//SET_VAR(ind_co, ctl->qnt_Cco);

		FIX[ind_h2o] = h2o * M;

		//VAR[ind_ch4] = 0;
		//VAR[ind_co2] = 0;

		/* Reaction rate ... */
		ko3p_o2_M = k3rd_jpl(M, 6.1e-34, 2.4, 0, 0);
		ko3p_o3 = ARR_ab(8e-12, 2060);
		ko1d_o2 = ARR_ab(3.3e-11, -55);
		ko1d_o3 = ARR_ab(2.4e-10, 0);
		ko1d_h2 = ARR_ab(1.2e-10, 0);
		ko1d_h2o = ARR_ab(1.63e-10, -60);
		ko1d_n2 = ARR_ab(2.15e-11, -110);
		ko1d_n2_2 = k3rd_jpl(M, 2.8e-36, 0.9, 0, 0);
		ko1d_n2o = ARR_ab(1.19e-10, -20);
		ko1d_ch4 = ARR_ab(1.75e-10, 0);
		ko1d_co2 = ARR_ab(7.5e-11, -115);
		ko1d_ccl3f = ARR_ab(2.3e-10, 0);
		ko1d_ccl2f2 = ARR_ab(1.4e-10, -25);
		ko1d_cclf3 = ARR_ab(8.7e-11, 0);
		ko3p_oh = ARR_ab(1.8e-11, -180);
		ko3p_ho2 = ARR_ab(3e-11, -200);
		ko3p_h2o2 = ARR_ab(1.4e-12, 2000);
		kh_o2_M = k3rd_jpl(M, 5.3e-32, 1.8, 9.5e-11, -0.4); 
		kh_o3 = ARR_ab(1.4e-10, 470);
		kh_ho2 = ARR_ab(7.2e-11, 0);
		kh_ho2_2 = ARR_ab(1.6e-12, 0);
		kh_ho2_3 = ARR_ab(6.9e-12, 0);
		koh_o3 = ARR_ab(1.7e-12, 940);
		koh_oh = ARR_ab(1.8e-12, 0);
		koh_oh_M = k3rd_jpl(M, 6.9e-31, 1.0, 2.6e-11, 0);
		koh_ho2 = ARR_ab(4.8e-11, -250);
		koh_h2o2 = 1.8e-12;
		koh_co = kcar_jpl(M, 6.9e-33, 2.1, 1.1e-12, -1.3, 1.85e-13, 65);
		kho2_o3 = ARR_ab(1e-14, 490);
		kho2_ho2 = ARR_ab(3e-13, -460) + ARR_ab(2.1e-33 * M, -920) ;
		
		/* Photolysis reaction rate ... */
		ko2_hv = roeth_photol(1.15e-11, 6.51657, 0.75717, sza);
		ko3_hv1 = roeth_photol(1.37e-4, 1.38520, 0.90333, sza);
		ko3_hv2 = roeth_photol(1.12E-03, 0.49409, 0.87117, sza);
		kho2_hv = roeth_photol(6.83E-06, 6.43722, 0.75746, sza);
		kh2o_hv = roeth_photol(1.79E-10, 7.70686, 0.75420, sza);
		kh2o2_hv = roeth_photol( 2.60E-05, 0.53675, 0.89531, sza);
		kn2o_hv = roeth_photol(1.61E-08, 6.21077, 0.76015, sza);
		kccl3f_hv = roeth_photol(6.79E-07, 6.25031, 0.75941, sza);
		kcl2f2_hv = roeth_photol(2.81E-08, 6.47452, 0.75909, sza);
}

// End INLINED Rate Law Functions

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// 
// Update_SUN - update SUN light using TIME
//   Arguments :
// 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void Update_SUN()
{
double SunRise, SunSet;
double Thour, Tlocal, Ttmp; 
const double PI = 3.14159265358979;  

  SunRise = 4.5;
  SunSet  = 19.5;
  Thour = TIME/3600.0;
  Tlocal = Thour - ((int)Thour/24)*24;

  if ( (Tlocal >= SunRise) && (Tlocal <= SunSet) ) {
    Ttmp = (2.0*Tlocal-SunRise-SunSet)/(SunSet-SunRise);
    if (Ttmp > 0) Ttmp =  Ttmp*Ttmp;
             else Ttmp = -Ttmp*Ttmp;
    SUN = ( 1.0 + cos(PI*Ttmp) )/2.0; 
  } else {
    SUN=0.0;
  }
}
// End of Update_SUN function
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// 
// Update_RCONST - function to update rate constants
//   Arguments :
// 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void Update_RCONST( 
)
{


// Begin INLINED RCONST


// End INLINED RCONST

  RCONST[0] = (ko3p_o2_M);
  RCONST[1] = (ko3p_o3);
  RCONST[2] = (ko1d_o2);
  RCONST[3] = (ko1d_o3);
  RCONST[4] = (ko1d_h2o);
  RCONST[5] = (ko1d_n2);
  RCONST[6] = (ko1d_n2_2);
  RCONST[7] = (ko1d_n2o);
  RCONST[8] = (ko1d_ccl3f);
  RCONST[9] = (ko1d_ccl2f2);
  RCONST[10] = (ko1d_cclf3);
  RCONST[11] = (ko3p_ho2);
  RCONST[12] = (ko3p_h2o2);
  RCONST[13] = (koh_o3);
  RCONST[14] = (koh_oh);
  RCONST[15] = (koh_oh_M);
  RCONST[16] = (koh_ho2);
  RCONST[17] = (koh_h2o2);
  RCONST[18] = (kho2_o3);
  RCONST[19] = (kho2_ho2);
  RCONST[20] = (ko2_hv);
  RCONST[21] = (ko3_hv1);
  RCONST[22] = (ko3_hv2);
  RCONST[23] = (kho2_hv);
  RCONST[24] = (kh2o2_hv);
  RCONST[25] = (kn2o_hv);
  RCONST[26] = (kccl3f_hv);
  RCONST[27] = (kcl2f2_hv);
}

// End of Update_RCONST function
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// 
// Update_PHOTO - function to update photolytical rate constants
//   Arguments :
// 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void Update_PHOTO( 
)
{

// Begin INLINED RCONST


// End INLINED RCONST

  RCONST[20] = (ko2_hv);
  RCONST[21] = (ko3_hv1);
  RCONST[22] = (ko3_hv2);
  RCONST[23] = (kho2_hv);
  RCONST[24] = (kh2o2_hv);
  RCONST[25] = (kn2o_hv);
  RCONST[26] = (kccl3f_hv);
  RCONST[27] = (kcl2f2_hv);
}

// End of Update_PHOTO function
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


