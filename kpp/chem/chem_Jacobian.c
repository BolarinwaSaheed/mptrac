// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// 
// The ODE Jacobian of Chemical Model File
// 
// Generated by KPP-3.0.0 symbolic chemistry Kinetics PreProcessor
//       (https:/github.com/KineticPreProcessor/KPP
// KPP is distributed under GPL, the general public licence
//       (http://www.gnu.org/copyleft/gpl.html)
// (C) 1995-1997, V. Damian & A. Sandu, CGRER, Univ. Iowa
// (C) 1997-2022, A. Sandu, Michigan Tech, Virginia Tech
//     With important contributions from:
//        M. Damian,   Villanova University, Philadelphia, PA, USA
//        R. Sander,   Max-Planck Institute for Chemistry, Mainz, Germany
//        M. Long,     Renaissance Fiber, LLC, North Carolina, USA
//        H. Lin,      Harvard University, Cambridge, MA, USA
//        R. Yantosca, Harvard University, Cambridge, MA, USA
// 
// File                 : chem_Jacobian.c
// Equation file        : chem.kpp
// Output root filename : chem
// 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include "chem_Parameters.h"
#include "chem_Global.h"
#include "chem_Sparse.h"


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// 
// Jac_SP - the Jacobian of Variables in sparse matrix representation
//   Arguments :
//      V         - Concentrations of variable species (local)
//      F         - Concentrations of fixed species (local)
//      RCT       - Rate constants (local)
//      JVS       - sparse Jacobian of variables
// 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void Jac_SP( 
  double V[NVAR],                        /* Concentrations of variable species (local) */
  double F[NFIX],                        /* Concentrations of fixed species (local) */
  double RCT[NREACT],                    /* Rate constants (local) */
  double JVS[LU_NONZERO]                 /* sparse Jacobian of variables */
)
{

// Local variables
double B[45];                            /* Temporary array */

// B(0) = dA(0)/dV(6)
  B[0] = RCT[0]*F[0];
// B(2) = dA(1)/dV(5)
  B[2] = RCT[1]*V[6];
// B(3) = dA(1)/dV(6)
  B[3] = RCT[1]*V[5];
// B(4) = dA(2)/dV(4)
  B[4] = RCT[2]*F[0];
// B(6) = dA(3)/dV(4)
  B[6] = RCT[3]*V[5];
// B(7) = dA(3)/dV(5)
  B[7] = RCT[3]*V[4];
// B(8) = dA(4)/dV(4)
  B[8] = RCT[4]*F[2];
// B(10) = dA(5)/dV(4)
  B[10] = RCT[5]*F[1];
// B(12) = dA(6)/dV(4)
  B[12] = RCT[6]*F[1];
// B(14) = dA(7)/dV(0)
  B[14] = RCT[7]*V[4];
// B(15) = dA(7)/dV(4)
  B[15] = RCT[7]*V[0];
// B(16) = dA(8)/dV(1)
  B[16] = RCT[8]*V[4];
// B(17) = dA(8)/dV(4)
  B[17] = RCT[8]*V[1];
// B(18) = dA(9)/dV(2)
  B[18] = RCT[9]*V[4];
// B(19) = dA(9)/dV(4)
  B[19] = RCT[9]*V[2];
// B(20) = dA(10)/dV(3)
  B[20] = RCT[10]*V[4];
// B(21) = dA(10)/dV(4)
  B[21] = RCT[10]*V[3];
// B(22) = dA(11)/dV(6)
  B[22] = RCT[11]*V[9];
// B(23) = dA(11)/dV(9)
  B[23] = RCT[11]*V[6];
// B(24) = dA(12)/dV(6)
  B[24] = RCT[12]*V[7];
// B(25) = dA(12)/dV(7)
  B[25] = RCT[12]*V[6];
// B(26) = dA(13)/dV(5)
  B[26] = RCT[13]*V[8];
// B(27) = dA(13)/dV(8)
  B[27] = RCT[13]*V[5];
// B(28) = dA(14)/dV(8)
  B[28] = RCT[14]*2*V[8];
// B(29) = dA(15)/dV(8)
  B[29] = RCT[15]*2*V[8];
// B(30) = dA(16)/dV(8)
  B[30] = RCT[16]*V[9];
// B(31) = dA(16)/dV(9)
  B[31] = RCT[16]*V[8];
// B(32) = dA(17)/dV(7)
  B[32] = RCT[17]*V[8];
// B(33) = dA(17)/dV(8)
  B[33] = RCT[17]*V[7];
// B(34) = dA(18)/dV(5)
  B[34] = RCT[18]*V[9];
// B(35) = dA(18)/dV(9)
  B[35] = RCT[18]*V[5];
// B(36) = dA(19)/dV(9)
  B[36] = RCT[19]*2*V[9];
// B(38) = dA(21)/dV(5)
  B[38] = RCT[21];
// B(39) = dA(22)/dV(5)
  B[39] = RCT[22];
// B(40) = dA(23)/dV(9)
  B[40] = RCT[23];
// B(41) = dA(24)/dV(7)
  B[41] = RCT[24];
// B(42) = dA(25)/dV(0)
  B[42] = RCT[25];
// B(43) = dA(26)/dV(1)
  B[43] = RCT[26];
// B(44) = dA(27)/dV(2)
  B[44] = RCT[27];

// Construct the Jacobian terms from B's
// JVS(0) = Jac_FULL(0,0)
  JVS[0] = -B[14]-B[42];
// JVS(1) = Jac_FULL(0,4)
  JVS[1] = B[12]-B[15];
// JVS(2) = Jac_FULL(1,1)
  JVS[2] = -0.9*B[16]-B[43];
// JVS(3) = Jac_FULL(1,4)
  JVS[3] = -0.9*B[17];
// JVS(4) = Jac_FULL(2,2)
  JVS[4] = -0.86*B[18]-B[44];
// JVS(5) = Jac_FULL(2,4)
  JVS[5] = -0.86*B[19];
// JVS(6) = Jac_FULL(3,3)
  JVS[6] = -0.82*B[20];
// JVS(7) = Jac_FULL(3,4)
  JVS[7] = -0.82*B[21];
// JVS(8) = Jac_FULL(4,0)
  JVS[8] = -B[14]+B[42];
// JVS(9) = Jac_FULL(4,1)
  JVS[9] = -B[16];
// JVS(10) = Jac_FULL(4,2)
  JVS[10] = -B[18];
// JVS(11) = Jac_FULL(4,3)
  JVS[11] = -B[20];
// JVS(12) = Jac_FULL(4,4)
  JVS[12] = -B[4]-B[6]-B[8]-B[10]-B[12]-B[15]-B[17]-B[19]-B[21];
// JVS(13) = Jac_FULL(4,5)
  JVS[13] = -B[7]+B[38];
// JVS(14) = Jac_FULL(4,7)
  JVS[14] = B[41];
// JVS(15) = Jac_FULL(5,4)
  JVS[15] = -B[6];
// JVS(16) = Jac_FULL(5,5)
  JVS[16] = -B[2]-B[7]-B[26]-B[34]-B[38]-B[39];
// JVS(17) = Jac_FULL(5,6)
  JVS[17] = B[0]-B[3];
// JVS(18) = Jac_FULL(5,7)
  JVS[18] = 0;
// JVS(19) = Jac_FULL(5,8)
  JVS[19] = -B[27];
// JVS(20) = Jac_FULL(5,9)
  JVS[20] = -B[35];
// JVS(21) = Jac_FULL(6,1)
  JVS[21] = 0.1*B[16];
// JVS(22) = Jac_FULL(6,2)
  JVS[22] = 0.14*B[18];
// JVS(23) = Jac_FULL(6,3)
  JVS[23] = 0.18*B[20];
// JVS(24) = Jac_FULL(6,4)
  JVS[24] = B[4]+B[6]+B[10]+0.1*B[17]+0.14*B[19]+0.18*B[21];
// JVS(25) = Jac_FULL(6,5)
  JVS[25] = -B[2]+B[7]+B[39];
// JVS(26) = Jac_FULL(6,6)
  JVS[26] = -B[0]-B[3]-B[22]-B[24];
// JVS(27) = Jac_FULL(6,7)
  JVS[27] = -B[25];
// JVS(28) = Jac_FULL(6,8)
  JVS[28] = B[28];
// JVS(29) = Jac_FULL(6,9)
  JVS[29] = -B[23]+B[40];
// JVS(30) = Jac_FULL(7,6)
  JVS[30] = -B[24];
// JVS(31) = Jac_FULL(7,7)
  JVS[31] = -B[25]-B[32]-B[41];
// JVS(32) = Jac_FULL(7,8)
  JVS[32] = B[29]-B[33];
// JVS(33) = Jac_FULL(7,9)
  JVS[33] = B[36];
// JVS(34) = Jac_FULL(8,4)
  JVS[34] = 2*B[8];
// JVS(35) = Jac_FULL(8,5)
  JVS[35] = -B[26]+B[34];
// JVS(36) = Jac_FULL(8,6)
  JVS[36] = B[22]+B[24];
// JVS(37) = Jac_FULL(8,7)
  JVS[37] = B[25]-B[32]+B[41];
// JVS(38) = Jac_FULL(8,8)
  JVS[38] = -B[27]-2*B[28]-2*B[29]-B[30]-B[33];
// JVS(39) = Jac_FULL(8,9)
  JVS[39] = B[23]-B[31]+B[35]+B[40];
// JVS(40) = Jac_FULL(9,5)
  JVS[40] = B[26]-B[34];
// JVS(41) = Jac_FULL(9,6)
  JVS[41] = -B[22]+B[24];
// JVS(42) = Jac_FULL(9,7)
  JVS[42] = B[25]+B[32];
// JVS(43) = Jac_FULL(9,8)
  JVS[43] = B[27]-B[30]+B[33];
// JVS(44) = Jac_FULL(9,9)
  JVS[44] = -B[23]-B[31]-B[35]-2*B[36]-B[40];
}

// End of Jac_SP function
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// 
// Jac_SP_Vec - function for sparse multiplication: sparse Jacobian times vector
//   Arguments :
//      JVS       - sparse Jacobian of variables
//      UV        - User vector for variables
//      JUV       - Jacobian times user vector
// 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void Jac_SP_Vec( 
  double JVS[LU_NONZERO],                /* sparse Jacobian of variables */
  double UV[NVAR],                       /* User vector for variables */
  double JUV[NVAR]                       /* Jacobian times user vector */
)
{
  JUV[0] = JVS[0]*UV[0]+JVS[1]*UV[4];
  JUV[1] = JVS[2]*UV[1]+JVS[3]*UV[4];
  JUV[2] = JVS[4]*UV[2]+JVS[5]*UV[4];
  JUV[3] = JVS[6]*UV[3]+JVS[7]*UV[4];
  JUV[4] = JVS[8]*UV[0]+JVS[9]*UV[1]+JVS[10]*UV[2]+JVS[11]*UV[3]
          +JVS[12]*UV[4]+JVS[13]*UV[5]+JVS[14]*UV[7];
  JUV[5] = JVS[15]*UV[4]+JVS[16]*UV[5]+JVS[17]*UV[6]+JVS[19]*UV[8]
          +JVS[20]*UV[9];
  JUV[6] = JVS[21]*UV[1]+JVS[22]*UV[2]+JVS[23]*UV[3]+JVS[24]*UV[4]
          +JVS[25]*UV[5]+JVS[26]*UV[6]+JVS[27]*UV[7]+JVS[28]*UV[8]
          +JVS[29]*UV[9];
  JUV[7] = JVS[30]*UV[6]+JVS[31]*UV[7]+JVS[32]*UV[8]+JVS[33]*UV[9];
  JUV[8] = JVS[34]*UV[4]+JVS[35]*UV[5]+JVS[36]*UV[6]+JVS[37]*UV[7]
          +JVS[38]*UV[8]+JVS[39]*UV[9];
  JUV[9] = JVS[40]*UV[5]+JVS[41]*UV[6]+JVS[42]*UV[7]+JVS[43]*UV[8]
          +JVS[44]*UV[9];
}

// End of Jac_SP_Vec function
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// 
// JacTR_SP_Vec - sparse multiplication: sparse Jacobian transposed times vector
//   Arguments :
//      JVS       - sparse Jacobian of variables
//      UV        - User vector for variables
//      JTUV      - Jacobian transposed times user vector
// 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void JacTR_SP_Vec( 
  double JVS[LU_NONZERO],                /* sparse Jacobian of variables */
  double UV[NVAR],                       /* User vector for variables */
  double JTUV[NVAR]                      /* Jacobian transposed times user vector */
)
{
  JTUV[0] = JVS[0]*UV[0]+JVS[8]*UV[4];
  JTUV[1] = JVS[2]*UV[1]+JVS[9]*UV[4]+JVS[21]*UV[6];
  JTUV[2] = JVS[4]*UV[2]+JVS[10]*UV[4]+JVS[22]*UV[6];
  JTUV[3] = JVS[6]*UV[3]+JVS[11]*UV[4]+JVS[23]*UV[6];
  JTUV[4] = JVS[1]*UV[0]+JVS[3]*UV[1]+JVS[5]*UV[2]+JVS[7]*UV[3]+JVS[12]
           *UV[4]+JVS[15]*UV[5]+JVS[24]*UV[6]+JVS[34]*UV[8];
  JTUV[5] = JVS[13]*UV[4]+JVS[16]*UV[5]+JVS[25]*UV[6]+JVS[35]*UV[8]
           +JVS[40]*UV[9];
  JTUV[6] = JVS[17]*UV[5]+JVS[26]*UV[6]+JVS[30]*UV[7]+JVS[36]*UV[8]
           +JVS[41]*UV[9];
  JTUV[7] = JVS[14]*UV[4]+JVS[27]*UV[6]+JVS[31]*UV[7]+JVS[37]*UV[8]
           +JVS[42]*UV[9];
  JTUV[8] = JVS[19]*UV[5]+JVS[28]*UV[6]+JVS[32]*UV[7]+JVS[38]*UV[8]
           +JVS[43]*UV[9];
  JTUV[9] = JVS[20]*UV[5]+JVS[29]*UV[6]+JVS[33]*UV[7]+JVS[39]*UV[8]
           +JVS[44]*UV[9];
}

// End of JacTR_SP_Vec function
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


